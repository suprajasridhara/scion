// Code generated by capnpc-go. DO NOT EDIT.

package proto

import (
	strconv "strconv"
	capnp "zombiezen.com/go/capnproto2"
	text "zombiezen.com/go/capnproto2/encoding/text"
	schemas "zombiezen.com/go/capnproto2/schemas"
)

type MS struct{ capnp.Struct }
type MS_Which uint16

const (
	MS_Which_unset       MS_Which = 0
	MS_Which_asActionReq MS_Which = 1
	MS_Which_asActionRep MS_Which = 2
	MS_Which_fullMapReq  MS_Which = 3
	MS_Which_fullMapRep  MS_Which = 4
)

func (w MS_Which) String() string {
	const s = "unsetasActionReqasActionRepfullMapReqfullMapRep"
	switch w {
	case MS_Which_unset:
		return s[0:5]
	case MS_Which_asActionReq:
		return s[5:16]
	case MS_Which_asActionRep:
		return s[16:27]
	case MS_Which_fullMapReq:
		return s[27:37]
	case MS_Which_fullMapRep:
		return s[37:47]

	}
	return "MS_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// MS_TypeID is the unique identifier for the type MS.
const MS_TypeID = 0xda155ff9f070267c

func NewMS(s *capnp.Segment) (MS, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return MS{st}, err
}

func NewRootMS(s *capnp.Segment) (MS, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return MS{st}, err
}

func ReadRootMS(msg *capnp.Message) (MS, error) {
	root, err := msg.RootPtr()
	return MS{root.Struct()}, err
}

func (s MS) String() string {
	str, _ := text.Marshal(0xda155ff9f070267c, s.Struct)
	return str
}

func (s MS) Which() MS_Which {
	return MS_Which(s.Struct.Uint16(8))
}
func (s MS) Id() uint64 {
	return s.Struct.Uint64(0)
}

func (s MS) SetId(v uint64) {
	s.Struct.SetUint64(0, v)
}

func (s MS) SetUnset() {
	s.Struct.SetUint16(8, 0)

}

func (s MS) AsActionReq() (ASMapEntry, error) {
	if s.Struct.Uint16(8) != 1 {
		panic("Which() != asActionReq")
	}
	p, err := s.Struct.Ptr(0)
	return ASMapEntry{Struct: p.Struct()}, err
}

func (s MS) HasAsActionReq() bool {
	if s.Struct.Uint16(8) != 1 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s MS) SetAsActionReq(v ASMapEntry) error {
	s.Struct.SetUint16(8, 1)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewAsActionReq sets the asActionReq field to a newly
// allocated ASMapEntry struct, preferring placement in s's segment.
func (s MS) NewAsActionReq() (ASMapEntry, error) {
	s.Struct.SetUint16(8, 1)
	ss, err := NewASMapEntry(s.Struct.Segment())
	if err != nil {
		return ASMapEntry{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s MS) AsActionRep() (MSRepToken, error) {
	if s.Struct.Uint16(8) != 2 {
		panic("Which() != asActionRep")
	}
	p, err := s.Struct.Ptr(0)
	return MSRepToken{Struct: p.Struct()}, err
}

func (s MS) HasAsActionRep() bool {
	if s.Struct.Uint16(8) != 2 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s MS) SetAsActionRep(v MSRepToken) error {
	s.Struct.SetUint16(8, 2)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewAsActionRep sets the asActionRep field to a newly
// allocated MSRepToken struct, preferring placement in s's segment.
func (s MS) NewAsActionRep() (MSRepToken, error) {
	s.Struct.SetUint16(8, 2)
	ss, err := NewMSRepToken(s.Struct.Segment())
	if err != nil {
		return MSRepToken{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s MS) FullMapReq() (FullMapReq, error) {
	if s.Struct.Uint16(8) != 3 {
		panic("Which() != fullMapReq")
	}
	p, err := s.Struct.Ptr(0)
	return FullMapReq{Struct: p.Struct()}, err
}

func (s MS) HasFullMapReq() bool {
	if s.Struct.Uint16(8) != 3 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s MS) SetFullMapReq(v FullMapReq) error {
	s.Struct.SetUint16(8, 3)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewFullMapReq sets the fullMapReq field to a newly
// allocated FullMapReq struct, preferring placement in s's segment.
func (s MS) NewFullMapReq() (FullMapReq, error) {
	s.Struct.SetUint16(8, 3)
	ss, err := NewFullMapReq(s.Struct.Segment())
	if err != nil {
		return FullMapReq{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

func (s MS) FullMapRep() (FullMapRep, error) {
	if s.Struct.Uint16(8) != 4 {
		panic("Which() != fullMapRep")
	}
	p, err := s.Struct.Ptr(0)
	return FullMapRep{Struct: p.Struct()}, err
}

func (s MS) HasFullMapRep() bool {
	if s.Struct.Uint16(8) != 4 {
		return false
	}
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s MS) SetFullMapRep(v FullMapRep) error {
	s.Struct.SetUint16(8, 4)
	return s.Struct.SetPtr(0, v.Struct.ToPtr())
}

// NewFullMapRep sets the fullMapRep field to a newly
// allocated FullMapRep struct, preferring placement in s's segment.
func (s MS) NewFullMapRep() (FullMapRep, error) {
	s.Struct.SetUint16(8, 4)
	ss, err := NewFullMapRep(s.Struct.Segment())
	if err != nil {
		return FullMapRep{}, err
	}
	err = s.Struct.SetPtr(0, ss.Struct.ToPtr())
	return ss, err
}

// MS_List is a list of MS.
type MS_List struct{ capnp.List }

// NewMS creates a new list of MS.
func NewMS_List(s *capnp.Segment, sz int32) (MS_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1}, sz)
	return MS_List{l}, err
}

func (s MS_List) At(i int) MS { return MS{s.List.Struct(i)} }

func (s MS_List) Set(i int, v MS) error { return s.List.SetStruct(i, v.Struct) }

func (s MS_List) String() string {
	str, _ := text.MarshalList(0xda155ff9f070267c, s.List)
	return str
}

// MS_Promise is a wrapper for a MS promised by a client call.
type MS_Promise struct{ *capnp.Pipeline }

func (p MS_Promise) Struct() (MS, error) {
	s, err := p.Pipeline.Struct()
	return MS{s}, err
}

func (p MS_Promise) AsActionReq() ASMapEntry_Promise {
	return ASMapEntry_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p MS_Promise) AsActionRep() MSRepToken_Promise {
	return MSRepToken_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p MS_Promise) FullMapReq() FullMapReq_Promise {
	return FullMapReq_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

func (p MS_Promise) FullMapRep() FullMapRep_Promise {
	return FullMapRep_Promise{Pipeline: p.Pipeline.GetPipeline(0)}
}

type ASMapEntry struct{ capnp.Struct }

// ASMapEntry_TypeID is the unique identifier for the type ASMapEntry.
const ASMapEntry_TypeID = 0xbf2197df52e713b4

func NewASMapEntry(s *capnp.Segment) (ASMapEntry, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 3})
	return ASMapEntry{st}, err
}

func NewRootASMapEntry(s *capnp.Segment) (ASMapEntry, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 3})
	return ASMapEntry{st}, err
}

func ReadRootASMapEntry(msg *capnp.Message) (ASMapEntry, error) {
	root, err := msg.RootPtr()
	return ASMapEntry{root.Struct()}, err
}

func (s ASMapEntry) String() string {
	str, _ := text.Marshal(0xbf2197df52e713b4, s.Struct)
	return str
}

func (s ASMapEntry) Ia() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s ASMapEntry) HasIa() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s ASMapEntry) IaBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s ASMapEntry) SetIa(v string) error {
	return s.Struct.SetText(0, v)
}

func (s ASMapEntry) Ip() (capnp.TextList, error) {
	p, err := s.Struct.Ptr(1)
	return capnp.TextList{List: p.List()}, err
}

func (s ASMapEntry) HasIp() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s ASMapEntry) SetIp(v capnp.TextList) error {
	return s.Struct.SetPtr(1, v.List.ToPtr())
}

// NewIp sets the ip field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s ASMapEntry) NewIp(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(s.Struct.Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = s.Struct.SetPtr(1, l.List.ToPtr())
	return l, err
}

func (s ASMapEntry) Timestamp() uint64 {
	return s.Struct.Uint64(0)
}

func (s ASMapEntry) SetTimestamp(v uint64) {
	s.Struct.SetUint64(0, v)
}

func (s ASMapEntry) Action() (string, error) {
	p, err := s.Struct.Ptr(2)
	return p.Text(), err
}

func (s ASMapEntry) HasAction() bool {
	p, err := s.Struct.Ptr(2)
	return p.IsValid() || err != nil
}

func (s ASMapEntry) ActionBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(2)
	return p.TextBytes(), err
}

func (s ASMapEntry) SetAction(v string) error {
	return s.Struct.SetText(2, v)
}

// ASMapEntry_List is a list of ASMapEntry.
type ASMapEntry_List struct{ capnp.List }

// NewASMapEntry creates a new list of ASMapEntry.
func NewASMapEntry_List(s *capnp.Segment, sz int32) (ASMapEntry_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 3}, sz)
	return ASMapEntry_List{l}, err
}

func (s ASMapEntry_List) At(i int) ASMapEntry { return ASMapEntry{s.List.Struct(i)} }

func (s ASMapEntry_List) Set(i int, v ASMapEntry) error { return s.List.SetStruct(i, v.Struct) }

func (s ASMapEntry_List) String() string {
	str, _ := text.MarshalList(0xbf2197df52e713b4, s.List)
	return str
}

// ASMapEntry_Promise is a wrapper for a ASMapEntry promised by a client call.
type ASMapEntry_Promise struct{ *capnp.Pipeline }

func (p ASMapEntry_Promise) Struct() (ASMapEntry, error) {
	s, err := p.Pipeline.Struct()
	return ASMapEntry{s}, err
}

type MSRepToken struct{ capnp.Struct }

// MSRepToken_TypeID is the unique identifier for the type MSRepToken.
const MSRepToken_TypeID = 0xd7387a16c86c1020

func NewMSRepToken(s *capnp.Segment) (MSRepToken, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return MSRepToken{st}, err
}

func NewRootMSRepToken(s *capnp.Segment) (MSRepToken, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return MSRepToken{st}, err
}

func ReadRootMSRepToken(msg *capnp.Message) (MSRepToken, error) {
	root, err := msg.RootPtr()
	return MSRepToken{root.Struct()}, err
}

func (s MSRepToken) String() string {
	str, _ := text.Marshal(0xd7387a16c86c1020, s.Struct)
	return str
}

func (s MSRepToken) SignedASEntry() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return []byte(p.Data()), err
}

func (s MSRepToken) HasSignedASEntry() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s MSRepToken) SetSignedASEntry(v []byte) error {
	return s.Struct.SetData(0, v)
}

func (s MSRepToken) Timestamp() uint64 {
	return s.Struct.Uint64(0)
}

func (s MSRepToken) SetTimestamp(v uint64) {
	s.Struct.SetUint64(0, v)
}

// MSRepToken_List is a list of MSRepToken.
type MSRepToken_List struct{ capnp.List }

// NewMSRepToken creates a new list of MSRepToken.
func NewMSRepToken_List(s *capnp.Segment, sz int32) (MSRepToken_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return MSRepToken_List{l}, err
}

func (s MSRepToken_List) At(i int) MSRepToken { return MSRepToken{s.List.Struct(i)} }

func (s MSRepToken_List) Set(i int, v MSRepToken) error { return s.List.SetStruct(i, v.Struct) }

func (s MSRepToken_List) String() string {
	str, _ := text.MarshalList(0xd7387a16c86c1020, s.List)
	return str
}

// MSRepToken_Promise is a wrapper for a MSRepToken promised by a client call.
type MSRepToken_Promise struct{ *capnp.Pipeline }

func (p MSRepToken_Promise) Struct() (MSRepToken, error) {
	s, err := p.Pipeline.Struct()
	return MSRepToken{s}, err
}

type FullMapReq struct{ capnp.Struct }

// FullMapReq_TypeID is the unique identifier for the type FullMapReq.
const FullMapReq_TypeID = 0x9f79403fb2002d32

func NewFullMapReq(s *capnp.Segment) (FullMapReq, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return FullMapReq{st}, err
}

func NewRootFullMapReq(s *capnp.Segment) (FullMapReq, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return FullMapReq{st}, err
}

func ReadRootFullMapReq(msg *capnp.Message) (FullMapReq, error) {
	root, err := msg.RootPtr()
	return FullMapReq{root.Struct()}, err
}

func (s FullMapReq) String() string {
	str, _ := text.Marshal(0x9f79403fb2002d32, s.Struct)
	return str
}

func (s FullMapReq) Id() uint8 {
	return s.Struct.Uint8(0)
}

func (s FullMapReq) SetId(v uint8) {
	s.Struct.SetUint8(0, v)
}

// FullMapReq_List is a list of FullMapReq.
type FullMapReq_List struct{ capnp.List }

// NewFullMapReq creates a new list of FullMapReq.
func NewFullMapReq_List(s *capnp.Segment, sz int32) (FullMapReq_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return FullMapReq_List{l}, err
}

func (s FullMapReq_List) At(i int) FullMapReq { return FullMapReq{s.List.Struct(i)} }

func (s FullMapReq_List) Set(i int, v FullMapReq) error { return s.List.SetStruct(i, v.Struct) }

func (s FullMapReq_List) String() string {
	str, _ := text.MarshalList(0x9f79403fb2002d32, s.List)
	return str
}

// FullMapReq_Promise is a wrapper for a FullMapReq promised by a client call.
type FullMapReq_Promise struct{ *capnp.Pipeline }

func (p FullMapReq_Promise) Struct() (FullMapReq, error) {
	s, err := p.Pipeline.Struct()
	return FullMapReq{s}, err
}

type FullMap struct{ capnp.Struct }

// FullMap_TypeID is the unique identifier for the type FullMap.
const FullMap_TypeID = 0xc7b2da00ffda93d6

func NewFullMap(s *capnp.Segment) (FullMap, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return FullMap{st}, err
}

func NewRootFullMap(s *capnp.Segment) (FullMap, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return FullMap{st}, err
}

func ReadRootFullMap(msg *capnp.Message) (FullMap, error) {
	root, err := msg.RootPtr()
	return FullMap{root.Struct()}, err
}

func (s FullMap) String() string {
	str, _ := text.Marshal(0xc7b2da00ffda93d6, s.Struct)
	return str
}

func (s FullMap) Id() uint8 {
	return s.Struct.Uint8(0)
}

func (s FullMap) SetId(v uint8) {
	s.Struct.SetUint8(0, v)
}

func (s FullMap) Ip() (string, error) {
	p, err := s.Struct.Ptr(0)
	return p.Text(), err
}

func (s FullMap) HasIp() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s FullMap) IpBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(0)
	return p.TextBytes(), err
}

func (s FullMap) SetIp(v string) error {
	return s.Struct.SetText(0, v)
}

func (s FullMap) Ia() (string, error) {
	p, err := s.Struct.Ptr(1)
	return p.Text(), err
}

func (s FullMap) HasIa() bool {
	p, err := s.Struct.Ptr(1)
	return p.IsValid() || err != nil
}

func (s FullMap) IaBytes() ([]byte, error) {
	p, err := s.Struct.Ptr(1)
	return p.TextBytes(), err
}

func (s FullMap) SetIa(v string) error {
	return s.Struct.SetText(1, v)
}

// FullMap_List is a list of FullMap.
type FullMap_List struct{ capnp.List }

// NewFullMap creates a new list of FullMap.
func NewFullMap_List(s *capnp.Segment, sz int32) (FullMap_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2}, sz)
	return FullMap_List{l}, err
}

func (s FullMap_List) At(i int) FullMap { return FullMap{s.List.Struct(i)} }

func (s FullMap_List) Set(i int, v FullMap) error { return s.List.SetStruct(i, v.Struct) }

func (s FullMap_List) String() string {
	str, _ := text.MarshalList(0xc7b2da00ffda93d6, s.List)
	return str
}

// FullMap_Promise is a wrapper for a FullMap promised by a client call.
type FullMap_Promise struct{ *capnp.Pipeline }

func (p FullMap_Promise) Struct() (FullMap, error) {
	s, err := p.Pipeline.Struct()
	return FullMap{s}, err
}

type FullMapRep struct{ capnp.Struct }

// FullMapRep_TypeID is the unique identifier for the type FullMapRep.
const FullMapRep_TypeID = 0xb0f5e5a599f7ce14

func NewFullMapRep(s *capnp.Segment) (FullMapRep, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return FullMapRep{st}, err
}

func NewRootFullMapRep(s *capnp.Segment) (FullMapRep, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return FullMapRep{st}, err
}

func ReadRootFullMapRep(msg *capnp.Message) (FullMapRep, error) {
	root, err := msg.RootPtr()
	return FullMapRep{root.Struct()}, err
}

func (s FullMapRep) String() string {
	str, _ := text.Marshal(0xb0f5e5a599f7ce14, s.Struct)
	return str
}

func (s FullMapRep) Fm() (FullMap_List, error) {
	p, err := s.Struct.Ptr(0)
	return FullMap_List{List: p.List()}, err
}

func (s FullMapRep) HasFm() bool {
	p, err := s.Struct.Ptr(0)
	return p.IsValid() || err != nil
}

func (s FullMapRep) SetFm(v FullMap_List) error {
	return s.Struct.SetPtr(0, v.List.ToPtr())
}

// NewFm sets the fm field to a newly
// allocated FullMap_List, preferring placement in s's segment.
func (s FullMapRep) NewFm(n int32) (FullMap_List, error) {
	l, err := NewFullMap_List(s.Struct.Segment(), n)
	if err != nil {
		return FullMap_List{}, err
	}
	err = s.Struct.SetPtr(0, l.List.ToPtr())
	return l, err
}

// FullMapRep_List is a list of FullMapRep.
type FullMapRep_List struct{ capnp.List }

// NewFullMapRep creates a new list of FullMapRep.
func NewFullMapRep_List(s *capnp.Segment, sz int32) (FullMapRep_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return FullMapRep_List{l}, err
}

func (s FullMapRep_List) At(i int) FullMapRep { return FullMapRep{s.List.Struct(i)} }

func (s FullMapRep_List) Set(i int, v FullMapRep) error { return s.List.SetStruct(i, v.Struct) }

func (s FullMapRep_List) String() string {
	str, _ := text.MarshalList(0xb0f5e5a599f7ce14, s.List)
	return str
}

// FullMapRep_Promise is a wrapper for a FullMapRep promised by a client call.
type FullMapRep_Promise struct{ *capnp.Pipeline }

func (p FullMapRep_Promise) Struct() (FullMapRep, error) {
	s, err := p.Pipeline.Struct()
	return FullMapRep{s}, err
}

const schema_de42b02816bdc1bf = "x\xdatTMhSY\x18=\xe7\xbb\xf9i\xa0o" +
	"\xc8\xe3\xa5\x9d\xce\xc0\xd0\x19\x18\x86\xceb\x86\xb63\x03" +
	"\xd32\xa5\xed0\x19,\x18\xe8M\x0a\x82\x08\xfa\xda\xa6" +
	"\x1al\xd2\xd7&E#\xdd\x08.\xc4\xad\x82v!\xd6" +
	"\xa0\xa0 XK\x17\x0aJ\x11\x04]\x09.T\xecB" +
	"W\xd2\xa5\xba(R\xaa>\xb9I\x93\xf4w\xf5.\xe7" +
	";\xdf9\xe7\xbb\xf7\xdd\xdb>\xc9>\xe9\x08~+\x80" +
	"n\x09\x86\xd6;\x7f[\xe8\xed+^\xd1\x11\xd2_z" +
	"\xf8\xa0\xb9m\xfe\xdf\xd7\x08\x84\x01\xfbC\xc9^3\xdf" +
	"\xd5^\xd0\x8f=\xfd8{\xfd\xed\xea<\xec\xc8&^" +
	"\x90a\xc0ib\xc9\xf9\xa1\xbc\xfa\x8e\x86\xbb\xe8\xac$" +
	"\xdf\\\xfci\x09[E\x83\xcaP\x06Xrt\x99\x9c" +
	"\xe0\x0a\xf8\xee\xc5\xf9e\x7fy\xe1\xf16\xaa\x18\xc2_" +
	"r\xce\xe9)\xaf\xba\xe46\xe8\xff\x18\x1d\x7f\xd2|\xea" +
	"\xef\x97\xdbu\xcbj\xcf\xa4\xe4\xbc*\x93\x9f\xcb\x09\xd0" +
	"\x9f\xf9\xc5{\xbfv\xb8i\xd9\x90\xa5N\x8e3\x1cd" +
	"\xc0\xe9R\xc3N\x8f\xc9\xf3G\x97:@\xd0\xcf\xe6\x7f" +
	"\x1fq\xbd\x9c\xc7\xee\xff\xa7\xc7\xc7\x13\xae\x17N\xa6'" +
	"\x07I\x1dP\x01 @\xc0\xb6\xbe\x07t\x83\xa2\x8e\x09" +
	"Uf\x94!\x08C{\xb4z{\xb4\xfe,TcY" +
	"~\x03\x0e*2Z\x9d\x1e4\xd0&\xa5\xfeT\xc2\xf5" +
	"\xe2\xb9pa\xaah\x94\xa25%\xd7(\x1dR\xd4\xc7" +
	"\x846\x19\xa3\x01\xd3\x06<\xa2\xa8g\x84\x94\x18\x05\xb0" +
	"\x8bI@\x9fT\xd4g\x84\xb6\x92\x18\x15`\x9f\xee\x06" +
	"\xf4\x8c\xa2>kFp\xd9\x08a#\xa82^5\x92" +
	"AL\x94B&\x9b\xce\x17\xdc,\xe81\x02a\x04\xec" +
	"uG\x0a\x99\x89\\\xb5i\xe7\xdc\x80\xc9\xdaX\xcb\x1a" +
	"7\xb1\xfa\x14\xf5~a5\xea\x80\xc1\xfeS\xd4\x83B" +
	"[X\xc9\x9a0\xe0>E=\xb4egM\xacZB" +
	"w\x17\xdfD*\x99\xf6\x86&\xc2\xc7\xd39\xe3\xdcP" +
	"s\xfeu\x0a\xd0m\x8a\xfa\xcf\xbas\x87\xd9\x90vE" +
	"\xfd\x8f\xd0\xcfg\x8e\xe6\xd2\xa3\xfd)\xb4\xc6s\x85\xa9" +
	"\"-\x08\xad\xdd\xc7\xae\xf9!\xdc\x9dH\x19\x9f\x96\x9a" +
	"\xcf\xac\x09~AQ\xcf\x09-\xfa~\xc5\xe9r'\xa0" +
	"/)\xeakBK\xbe\xf8\x95!\xaf\x0e\x03zNQ" +
	"\xdf\x12Z\xea\xb3_9\x91\x9b\x06\xbd\xa1\xa8\x17\x85V" +
	"\xe0\x93\x1fc\x00\xb0\xef\x1c\x04\xf4\xbc\xa2\xbe/\xb4\x82" +
	"\xeb~\x8cA\xc0\xbeg\xd0\xbb\x8a\xfaQe\x9b6\x02" +
	"\xb6N\xe7\xf2\xe9\x02B\xbe\x9b\xef/\x9f\x10\xcc\xbf\xcb" +
	"h\xfd\x1e\x82\x8c\x82[\xea\x1e\xa3\xf5\xfb\xb4Q\x1f\xab" +
	"\x1cc\x12\xca\xb4W_\x86\x9dE\xd3[{\x0f*\xe5" +
	"\xaf\x01\x00\x00\xff\xffE\x0a\x02}"

func init() {
	schemas.Register(schema_de42b02816bdc1bf,
		0x9f79403fb2002d32,
		0xb0f5e5a599f7ce14,
		0xbf2197df52e713b4,
		0xc7b2da00ffda93d6,
		0xd7387a16c86c1020,
		0xda155ff9f070267c)
}
